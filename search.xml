<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VSCode 编辑MarkDown文件]]></title>
    <url>%2F2019%2F08%2F31%2FVSCode-%E7%BC%96%E8%BE%91MarkDown%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[VSCode安装VSCode目前是很流行的文本编译器，加上有丰富的插件，基本上可以把VSCode当作IDE来使用了，此次仅介绍用VSCode写MarkDown文件。 安装进入VSCode官网,选择对应操作系统的版本进入下载，下载完成之后进行安装，不同的操作系统安装方法不尽相同，在这边不在过多阐述，安装完成之后，打开VSCode,我这边因为是已经配置过的，所以显示可能会不太一样，通常情况下是显示英文。 插件下载VSCode的插件非常丰富，点击左侧的侧边栏Extensions位置，便可以进行搜索插件并下载上面说到VSCode第一次打开应该是英文，显示中文是我下载了中文的插件，在插件一栏中输入Chinese就可以看到该插件，点击Install就可以尽心下载了。 现在VSCode的插件都很人性化，基本上你打开一个文件，它就会推荐相应的插件想你询问是否安装，对于markdown文件，打开Extensions，输入markdown，一般选择下载量最大的那个。 这个 All in one基本上就把MarkDown要使用的插件全部下载下来了。不过，你可能还不清楚，MarkDown也可以画图，可以下载Mermaid插件，mermaid目前可以画流程图，时序图，甘特图，你可以在MarkDown中使用，像输入如下代码1234`` ` mermaidgraph LRhello --&gt; world``` ⚠️在实际使用中，第一行的三个点(```)之间是没有空格的,因为hexo这边会把这个转为js代码，为了显示要求，只好在这三个点里加个空格 显示效果如下所示 graph LR hello --> world更多画法，参考mermaid官网 在文章的最后，在推荐一款所见即所得的MarkDown软件Typora,这个软件安装好之后就可以使用，不需要去弄那些配置。]]></content>
      <tags>
        <tag>Software Installation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用DigitalOcean服务器进行网络代理]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BD%BF%E7%94%A8DigitalOcean%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[在学习了计算机网络，其中有一章为网络代理，什么是网络代理？打个比喻就是相当与两个人在对话，但他们中间隔着一堵墙，导致这两个人的对话出现障碍，但是刚好有个“幽灵”，它可以透过这堵墙，将两个人的聊天信息转发给对方。通过这个“幽灵”这两个人就可以正常聊天，不会受到这个墙的影响。 现在你在上网，刚好要访问一个放在远程服务器的网页，此时你的电脑和远程的服务器相当于上述两个聊天的人，但是由于距离太远，相当于一堵墙，此时需要一个“幽灵”来帮助你们之间的信息传输。在此使用DigitalOcean的服务器来实现“幽灵”的功能，也就是网络代理。 注册DigitalOcean账号首先去DigitalOcean上去注册账号,就会送你10美元，现在政策好像改为100刀60天使用权了。登入之后看到如下界面，点击Create之后选择Droplets接着选择CentOS操作系统，再选择服务器的型号，如果你的网络地址支持IPv6的话，还可以添加上IPv6的地址 在选择好上述选项后点击确认创建，之后DigitalOcean就会给你发送邮件,里面有该服务器的IP地址，用户名和用户密码 在Windows下通过Xshell来连接到远程的服务器，新建一个会话，输入服务器IP地址，确认后，在连接成功后就可以输入用户名和密码进行连接 如果电脑上有安装Git或者Bash Shell可以支持SSH连接的命令行工具的话，可以使用ssh 用户名@IP地址，该教程下，用户名为root，IP地址DigitalOcean提供，在建立连接之后，才会让你输入密码。 BBR 加速首先进行BBR加速，输入1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 如果这个命令运行有问题的话，将这个命令拆成三个命令运行1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 1chmod +x bbr.sh 1./bbr.sh 一些Linux系统在最初命令可能会不全，需要下载相应的命令，在这个安装过程中，用到的wget这个命令可能会缺失，如果是RedHat系的Linux系统，使用yum install wget，如果是Debian系，使用apt install wget，本文使用的是CentOS，属于RedHat系的，使用第一个命令行就可以进行安装。 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：1sysctl net.ipv4.tcp_available_congestion_control 返回值为1net.ipv4.tcp_available_congestion_control = bbr cubic reno 输入1sysctl net.ipv4.tcp_congestion_control 返回值为1net.ipv4.tcp_congestion_control = bbr 返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。 ShadowsocksR 安装输入1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh 1chmod +x shadowsocksR.sh 1./shadowsocksR.sh 上面的3行代码要依次复制然后粘贴到ssh里，运行后出现如下界面，可以自己设置密码，否则服务器采用默认的密码设置端口设置加密协议，一般采用默认值设置协议和混淆参数，一般情况下使用默认值配置完后，安装ShadowsocksR并显示出当前配置好的参数进入配置文件，将IPv6的参数改为“true”，这样就可以使用IPv6的通道然后输入1/etc/init.d/shadowsocks status 可以查看 ShadowsocksR 进程是否已经启动如果显示 running表示已经启动。 这样就实现了“幽灵”这一角色的功能，最后只要在自己的客户端上安装ShadowsocksR就可以使用了，这样就完成了网络代理了。]]></content>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2019%2F03%2F17%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经过前几篇的讲解，Git的基本操作就是这些，我也自己通过思维导图整理出来，供大家参考： 有需要的话，也可以进入在线预览 在此介绍的都是一些常用的Git命令，Git是一个版本控制工具，工具的熟练程度一定是通过经常使用才熟悉的，所以一定要去找一个项目练练手。像基于Git的代码托管平台最有名气的就是GitHub，当然在国内的话，有coding, 码云等平台，可以入手一个动手实践一下。不过，如果想自己打一个代码托管平台，也是可以的，你可以自己买个VPS，在上面部署Git，具体步骤可自已通过搜索引擎查找。 如果基础的Git命令已经掌握了，想进一步进阶的话，首推Git官网出版的Git说明书 Pro Git 如果平时忘记了Git的命令行的使用，还是到搜索引擎查找吧。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore配置]]></title>
    <url>%2F2019%2F03%2F16%2Fgitignore%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在使用Git进行版本管理，有时候一些文件不需要提交，但使用git status 命令后会出现未提示的文件，我们可以用.gitignore 文件对不必要的文件进行屏蔽。&emsp;&emsp;在Windows系统下进行配置.gitignore文件，确实有点难受。首先Windows操作系统下，直接右击鼠标无法新建一个不带文件名的文件，因此我们打开Git命令行，输入touch .gitignore命令你就可以在该文件夹下找到.gitignore文件(其实这是Bash shell下创建一个文件的命令，在介绍Git命令的一篇文章中说过，Git的命令行模式下是一种shell，不信你可以在你的Git命令行模式下输入bash shell的命令，它是可以运行，只不过命令没有那么全而已)，建议用vscode或者其他文本编辑器编辑该文件。下面介绍.gitignore 文件的编写： .gitignore中特殊符号： “#”相当于程序的注释的标记，“#”后的内容都会被忽略掉；同时空行也会被忽略掉； “/”表示目录，这个实际上是Linux下的目录表示，其中有绝对路径和相对路径的写法，绝对路径的意思是从一个头开始而这个头的表示为/，例如在Windows下你的C盘里有一个Windows目录，那么表示该目录为/c/Windows；相对的路径的意思为从当前目录开始表示为./开头，如果你已经在C盘，则上面目录的表示为./Windows； “*”为通配符，表示可以匹配任意多个字符； “?”表示匹配任意单个字符； “[]”表示单个字符的匹配列表； “!”表示不忽略匹配到的文件或目录。 举些例子： 忽略指定的文件，比如要忽略readme.md，那么直接在.gitignore文件中编辑readme.md并保存，如要忽略所有后缀为.md的文件可以在.gitignore中编辑为*.md， *号出现表示在.md之前可以出现任意个字符(当文件名中有空格，要用&#39;&#39; 包含起来如&#39;Program Files&#39;/，这是Windows下的操作，一般的类Unix系统文件名都不允许有空格) 忽略指定文件夹，比如要忽略文件夹bin，则在.gitignore文件编辑bin/,如果是所有文件夹下都要有bin文件夹，并要忽略该文件可编写为*/bin/; 如果一个文件夹中你只需要其中的一两个，那么可以先忽略该文件夹，再用“!”提出需要的文件，例如你bin文件夹下，你只需要其中的readme.md文件，但它有十来个文件，此时.gitignore文件可编辑为 12bin/!bin/readme.md &emsp;&emsp;这样.gitignore文件就配置好了，不觉得很麻烦吗？其实早有人就提供相应的’.gitignore’配置文件，找到你要的部分，就可以直接拿来用，可点击查看。在开启一个工程的时候，一定要去配置一下.gitignore文件，一个项目里面有部分文件是跟本地配置相关的，不应该添加到Git的管理中，不同的电脑，本地配置也会不一致，每个人都提交到Git中就会造成混乱。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令介绍Ⅳ]]></title>
    <url>%2F2019%2F03%2F15%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8DIV%2F</url>
    <content type="text"><![CDATA[前面讲了那么多的Git操作，都是在同一个分支里面操作的，没有体现出来分布式的概念，那么Git的分布式是怎样的呢？Git的分布式主要体现在分支(branch)上，那么下面就详细介绍branch的相关操作。 什么是分支，你可以看树杈，它有多个分支，Git的分支也是这样的，一个主分支，可以有多个其他分支。在建立一个Git仓库的时候，你就在一个分支里面了，那个分支就是master分支，一般叫做主分支。 那么你要创建自己的分支可以使用git branch 分支名， 创建你的分支，再通过git checkout 分支名 来切换到你的分支。也可以使用git checkout -b 分支名直接新建并进入新的分支。 创建一个分支的话，是在你当前所在这个分支的基础上，创建一个跟你当前所在分支一模一样的分支，后续的修改之类的分支互不影响。 可以通过git branch查看当前项目的所有分支，前面带*号的就是当前所在的分支 如果有个分支不需要了，那么，使用git branch -d 分支名删除分支，如果有特殊情况，要强制删除掉某一分支，使用git branch -D 分支名。切记不能在当前分支删除当前分支，必须切换到别的分支再执行删除操作。 与树杈不同的是，树杈一个分支分出去之后，就不会回来，但是Git的分支可以合并到任意一个分支。Git的合并是将一个分支合并到当前分支里面。一般有两种合并方式： git merge 分支名，这个合并可以保留分支来源。 git rebases 分支名，将要合并的分支中新的内容直接加在当前分支后面，不会保留分支来源。 一般团队合作的话，使用git merge这样就可以追根溯源了，个人的话可以使用git rebase，这样可以使提交记录更加简洁。 同时分支也会带来冲突问题，如果两个分支同时处理一个文件，那么就会产生冲突，需要我们手动解决。 有冲突的话，Git会有提示，会在分支名的后面标MERGING 打开有冲突的文件，可以看到文件文件里面，Git都标出来了那边有冲突，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD到======表示当前分支在这个文件的修改，=======到&gt;&gt;&gt;&gt;&gt;&gt;分支名表示这个这个分支对这个文件的修改，根据需要修改冲突后，再使用git add和git commit的命令之后就可以了。 这样本地分支常用的操作就是这些了。剩下的就是远程的，远程的操作主要有：与远程主机创建连接，上传新的内容，从远程主机获取新的内容。 与远程主机建立连接有两种协议：SSH 和 HTTPS，这两个具体协议的区别可以自己去查询，这里只介绍如何再这两种不同的协议建立连接。 首先，HTTPS的连接方式比较简单，只需要使用git clone 地址连接，会让你输入账号和密码，在之后的提交中，可能你每次的提交到远程主机上都需要输入一次账号和密码，就显得有些麻烦了。 使用SSH协议，不过，你需要先生成SSH密钥，使用ssh-keygen -t rsa -C 邮箱，邮箱一定是你在某一平台上的注册账号留下的邮箱。后面会有让你输入，直接按‘Enter’键。上面会有生成密钥的文件目录。 之后去那个目录里面，会有一个id_rsa.pub，打开此文件，将里面的内容粘贴到相应平台设置SSH的地方，这样远程主机就能识别出你使用的这台电脑了。 与远程主机建立联系的话，如果你是现在远程主机上建立的项目，本地是空的话，可以直接使用git clone把项目拷贝下来。如果是本地已经有一个项目了，要放在远程主机的话，现在远程主机上建立一个空的项目，然后使用git remote add 远程主机名 远程链接，一般远程主机名使用origin，这样就建立好了远程联系了。 一般第一次提交的话，使用git push -u origin master，后续的提交的话就可以直接用git push 远程主机名 本地分支名，这个命令的完整格式是：git push 远程主机名 本地分支名:远程分支名，一般而言，远程分支名与本地分支名一致，这样便于管理。如果删除远程的一个分支的话，本地分支名就不用写了，即git push 远程主机名 :远程分支名 从远程分支获取更新但不合并： git fetch 远程主机名 远程分支名从远程分支获取更新并合并：git pull 远程主机名 远程分支名:本地分支名 上述就是Git分支的主要操作，相信你熟悉了这写操作之后就可以使用Git进行团队开发了。(注意命令中的:为英文的字符)]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令介绍Ⅲ]]></title>
    <url>%2F2019%2F02%2F18%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8DIII%2F</url>
    <content type="text"><![CDATA[在使用git的过程中，并不是每一次的add，commit都是你所预期要提交的，总有失手的时候，有可能你在add的时候你多加了个文件，或者commit之后你后悔了，觉得这次的提交不应该包含这么多的东西。Git的设计还是很友好的，让你有后悔的机会去改正。 介绍几个常见的情形： 你在一次任务完成后，你要提交代码，使用git add .命令，在未使用commit命令之前，你觉得有一个文件现在提交太早了，那么，你可以使用git rm --cached 文件名， 记得要加--cached，表示是删除暂存区里的，如果直接使用git rm那么会把你本地的文件也删除掉。 如果你既add，又commit了, 然后稍加思考，觉得事情不对，觉得刚才的commit message写得有问题， 那么请敲下git commit --amend，然后就会跳到vi模式下，进行编辑你上一次的提交的信息。 如上图所示，你需要修改的就是那写黄体的字，黄体字下面是你上一次提交的信息。 如果你仔细思考，发现上一次提交的是什么鬼，决定全部删掉此次的提交重来，那么你有两个选择： 使用git reset 提交的标识号，先打印出你要回退的提交的标识号，使用git log， 或者上一篇文章里提到的git log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit当然正常人是不会去打这么一大长串的命令，正常的都配成别名alias， 比如，我要回退到下图中标记的提交，那么在控制台输入git reset 96a6128 你可以通过这个命令回退到任何一个你需要的版本，但是在该提交之后的所有提交后都会没有，不过，当你的终端没有关闭，你可以找到之前的log中你最近提交的标识号，然后再用git reset，如果只是想单纯看看那次的提交是什么，你可以使用git checkout 提交的标识号, 这个命令会保持所有的提交不会被删除，你要回到当前分支的最新提交，就输入git checkout 分支名 使用git revert 提交的标识号， 这个是git生成一个新的提交，这个的提交与你要回退的提交一模一样，比如你现在提交的分支是a-&gt;b-&gt;c-&gt;d，但是现在你想回到c，现在你只需撤销d的提交就可以回到c的状态了，即输入命令git revert d，这样你的仓库状态就回到c状态。所以在版本控制中，更倾向与使用revert来回退版本，这样可以保留之前的所有信息。 如果你在编辑一个文件，突然发现，这还不如之前写得好，但是你又记不清你之前具体写的内容，你总不能一直用Ctrl + z，来撤销你的操作，一直回到最初状态，在git中，用git checkout 文件名，就可以恢复文件。 当然一般最难受的时候就是，在你开发一个新的功能的时候，有人跟你说之前的功能有问题，你需要去修改bug，那你手头的工作还没保存下来，你也不能提交，这样会造成不必要的提交日志，你可以使用git stash，将你目前的工作先存放起来，当你修改完bug后要回到你之前的工作，使用git stash pop。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令介绍Ⅱ]]></title>
    <url>%2F2019%2F02%2F07%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8DII%2F</url>
    <content type="text"><![CDATA[现在就来介绍Git在本地分支的操作，首先通过Bash命令来创建一个test文件夹，在该文件夹下创建一个a.txt 其实Git在Windows下的命令行终端里面是简化的Bash Shell，如果你对Linux下的Bash Shell 比较熟悉的话，你可以通过该终端进行相关的操作，不过一些命令还是不可以使用的，你可以到GNU下载相关的package，进行相关配置，就可以像在Linux下运行相关命令。 先通过git init来初始化本地Git仓库，接着编辑a.txt 要在本地仓库提交的话，需要进行先运行git add, 再进行git commit。其中git add是将你当前的仓库内容提交到暂存区，暂存区的话，你可以把它当作你去从家坐车到学校，那么车就是你从家到学校的暂存区，执行git add相当与你现在坐上车，再git commit之后才能到目的地即工作区完整的命令如下：12git add 你要提交的文件名或文件夹名git commit -m "提交信息" 此时你会发现无法提交，因为Git不知道你是谁，就像如果你座的车是动车的话，你得有身份证才能够买票就座，所以此时Git给出相应的提示，让你告诉Git你是谁。 12git config --global user.email "你的邮箱地址"git config --global user.name "你的名字" 登记自己的名字和邮箱之后，可以通过12git config user.namegit config user.email 来查看是否登记成功再次进行git commit，可以查看结果：此时就提交成功，想想如果有10+个文件要提交，那么你add的时候一定要打那么多的文件名吗？其实可以使用git add --all表示将当前的所有未提交或者被改变了的文件提交到暂存区里面。 这样的话，我们就要知道当前工作区里面是否有改变，就需要使用git status来查看当前目录下的文件是否发生变化。可以增加一个b.txt及修改a.txt里面的内容之后来看由此可以看到，git是很智能的，他提示a.txt被修改，b.txt未被跟踪，接着用git add 与 git commit提交如果git add和git commit的次数多了，怎么知道之前的commit是什么？，可以使用git log来显示每一次的提交这个偶尔会有可能中文显示不出来，可以使用下述命令行来显示中文1git config --global core.quotepath false 虽然这个命令行很有用，但是每次显示的太臃肿了，信息太多，我们需要一个比较简明的内容，这时候就需要考虑到强大的别名alias1git config --global alias.logs "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 通过logs别名输出简明的Git日志。Git还提供打标签的功能，当你的项目完成到一定程度的时候，可以打个标签标记一下，使用git tag 标签名，这样就算是打上一个标签了，可以使用git tag，查看所有的标签，要切换到某一个标签的话，可以使用git checkout 标签名。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令介绍Ⅰ]]></title>
    <url>%2F2019%2F01%2F24%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D1%2F</url>
    <content type="text"><![CDATA[使用Git，通过命令行操作能够更深入理解Git的工作机制，今天就来介绍一些常用的Git命令。 对于命令行的使用，都会提供一个用户手册，不过不出意外的话一般都会提供英文版本的，英语好的话就可以直接阅读，如果英语不太好的话，也可以去网上查询中文的使用指南。 现在先介绍Git的第一个命令1git help 在终端敲好该命令后，按下回车，你会看到如下的显示： 可以看到help界面中把Git的操作分为5类，后续的文章会根据这个顺序来解释这些命令。可以看到这个help页面中，对于Git命令的分类为： 开始一个工作空间 对当前的工作空间进行操作 检查历史记录和状态 对历史记录的操作 合作 上述这些操作也是使用Git的一般过程：从创建一个工作空间，对该工作空间进行的操作，操作的过程中会对历史记录进行操作，共享该工作空间与他人合作。 现在继续介绍git help命令，如果你忘了某个命令的具体使用，比如clone这个命令，那么，你可以在控制台上输入git help clone之后你的浏览器就会显示出给命令的详细帮助手册(不需要联网，所有的帮助文档都在你的本地硬盘里)，然而很可惜，还是英文的。还是像上文说的那样，这种官方帮助文档，你可以不使用，但你要知道有这么一种东西，万一哪天情况很急，你又忘记了某一个命令的是有而且还没有其他的途径来获取帮助，这时候就可以通过官方提供的文档来解决你的问题。 接着我们来介绍一下开启一个工作空间的两种方法从已有的项目直接复制一份过来，在此基础上进行后续的工作1git clone URL路径 比如在GitHub上要复制一个项目， 先该项目的主界面下，找到Clone or download按钮，然后复制提供的路径，对于开源的项目，提供的HTTPS还是SSH连接没有什么区别，对于私有的项目会有些许区别，这在后续会介绍，操作如下图所示：在终端输入1git clone https://github.com/GroverZhu/JSP-Servlet.git 之后就会在你的终端的目录下复制下该项目这个命令用的好，代码写得少。身边的人，Git用的不好，但这个命令记得可清楚了，一天完成n个项目不再是梦，别问怎么写的，问就是git clone。从零开始创建一个工作空间1git init 选择一个目录，可以使用bash命令创建一个文件夹mkdir tmp，然后进入该文件夹cd tmp/,再输入git initinit就是initial的缩写，即初始化，之后你可以进入文件夹tmp中查看，会有一个隐藏文件夹.git，这样就初始化好了，你就拥有一个Git工作空间了 此次对Git命令的介绍就到此，Git的掌握一定要通过自己亲手操作，Git是一个工具，工具的掌握就是熟能生巧。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简介]]></title>
    <url>%2F2019%2F01%2F23%2FGit%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[关于Git，对于程序员肯定不陌生，全球最大“同性交友”网站GitHub便是基于Git创建，Git与GitHub的关系，从名字上就可以看出GitHub就是基于Git的一个仓库(hub)，Git是一个分布式版本控制软件，而GitHub就是基于该版本控制软件而创建的一个网站。 有些人会觉得Git与GitHub其实差不多，但实际上，如果你需要往GitHub这个网站上传你的代码，那么你需要通过Git该分布式版本控制软件来上传你的代码，但是你要查找别人的代码，那么你就需要从GitHub这个网站上搜索，对于网站的操作，并不会很麻烦，有图形化界面，所以我们的目标应该是先放在对Git这个分布式版本控制软件的使用。所以在上面讲了那么多次Git是分布式版本控制软件，那么什么叫分布式，什么又叫版本控制软件。对于分布式，你可以理解为“鸡蛋不能放在同一个筐里”，版本控制可以理解为，你导师要你写一份论文，但是每次你提交论文给你的导师，他都会提一些修改，你为了避免改后的论文比之前的还要糟糕，你把每次提交的论文都保存下来，然后你的论文就变成下面这样的形式： “paper1.docx”“paper2.docx”“paper3.docx”… 那么，如果你使用了版本控制软件之后，你就可以在每次修改之后把每次修改的内容写一个概要，但是你的论文文件就只有一个文件，就不会像前面那样会产生无数个文件，到最后连自己都不知道哪个是最新的了，这就是版本控制。 那么你的文件就相当于那些“鸡蛋”，分布式就是你把这些“鸡蛋”放在不同的“篮筐”里，Git就是 “鸡蛋”+“篮筐” 既然Git是个软件，就先到Git官网针对你的操作系统安装对应的版本，博主是在Windows10下安装，其他平台安装可参考其他网站，在Windows下安装，可以一键next，安装后，右击鼠标会出现Git Bash Here和Git GUI Here , 如下图所示： 出现上图的图标，那么恭喜骚年，你安装成功了，后面的话，就会对Git的命令行使用进行解释 也许，你会觉得我在逗你玩，那不是有GUI吗？干嘛不用GUI却去用了命令行，是不是自讨苦吃啊！但是我说你不觉得用命令行整个逼格就高了吗？ 当然GUI确实入门比较快，如果你很排斥命令行的话，可自行搜索Tortoise Git，这个我没有用过,但是身边有人用过，反映这个比Git自带的GUI友好些，如果你想更熟练地使用Git，那我还是建议你使用命令行，毕竟Git最初的设计就是在命令行下使用的。在后续的文章我只会介绍Git的命令行操作]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL练习]]></title>
    <url>%2F2019%2F01%2F22%2FSQL%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[已知某数据库中存在如下四张表：1234department(dNo,dName,officeRoom,homepage)student(sNo,sName,sex,age,dNo)course(cNo,cName,cPNo,credit,dNo) sc(sNo,cNo,score,recordDate) Query一、单表1.查询所有年龄大于等于20岁的学生学号、姓名；123select sNo, sName from student where age &gt;= 20; 2.查询所有姓钱的男生学号、姓名、出生年份；123select sNo, sName, 2018 - age from student where sName like '钱%' and sex = '男'; 3.查询所有学分大于3的课程名称；123select cName from coursewhere credit &gt; 3; 4.查询所有没有被分配到任何学院的学生姓名；123select sName from student where dNo is null; 5.查询所有尚未设置主页的学院名称。123select dName from department where homepage is null; 二、聚集1.查询各个学院的平均年龄；123select dNo, avg(age) from student group by dNo; 123select department.dNo, department.dName, avg(age) from student left join department on (student.dNo = department.dNo)group by department.dNo, department.dName; 2.查询每个学生选修课程的平均分；1234select sNo, avg(score) from sc where score is not null group by sNo; 1234select student.sNo, student.sName, avg(score)from student, scwhere student.sNo = sc.sNo and sc.score is not nullgroup by student.sNo, student.sName; 3.查询各课程的平均分；1234select cNo，avg(score) from sc where score is not null group by cNo; 1234select course.cNo, course.cName, avg(score)from course, scwhere course.cNo = sc.cNo and sc.score is not nullgroup by course.cNo, course.cName; 4.查询各学院开设的课程门数；123select dNo, count(cNo) from course group by dNo; 123select department.dNo, department.dName, count(course.cNo)from department join course using(dNo)group by department.dNo, department.dName; 5.查询各门课程选修人数。123select cNo, count(sNo) from sc group by cNo; 123select course.cNo, course.cName, count(sc.sNo)from sc join course using (cNo)group by course.cNo, course.cName; 三、多表1.查询“信息学院”所有学生学号与姓名；123456select sNo, sNamefrom studentwhere dNo in (select dNo from department where dName = '信息学院'); 123select sNo, sNamefrom student, departmentwhere student.dNo = department.dNo and department.dName = '信息学院'; 123select student.sNo, student.sNamefrom student join department using (dNo)where department.dName = '信息学院'; 123select student.sNo, student.sNamefrom student join department on (student.dNo = department.dNo)where department.dName = '信息学院'; 2.查询“软件学院”开设的所有课程号与课程名称；123456select cNo, cNamefrom coursewhere dNo in (select dNo from department where dName = '软件学院'); 3.查询与“陈丽”在同一个系的所有学生学号与姓名；123456select sNo, sNamefrom studentwhere dNo in (select dNo from student where sName = '陈丽'); 4.查询与“张三”同岁的所有学生学号与姓名；123456select sNo, sNamefrom studentwhere age = (select age from student where sName = '张三'); 5.查询与“张三”同岁且不与“张三”在同一个系的学生学号与姓名；12345678910select sNo, sNamefrom studentwhere age = (select age from student where sName = '张三') and dNo &lt;&gt; (select dNo from student where sName = '张三'); 6.查询学分大于“离散数学”的所有课程名称；123456select cNamefrom coursewhere credit &gt; (select credit from course where cName = '离散数学'); 7.查询选修了课程名为“组合数学”的学生人数；123456789select count(sNo)from studentwhere sNo in (select sNo from sc where cNo in (select cNo from course where cName = '组合数学')); 8.查询没有选修“离散数学”的学生姓名；123456789select sNamefrom studentwhere not exists (select * from sc where sNo = student.sNo and cNo = (select cNo from course where cName = '离散数学')); 9.查询与“算法设计与分析”、“移动计算”学分不同的所有课程名称；12345678910select cNamefrom course as c1where (c1.credit &lt;&gt; (select credit from course where cName = '算法设计与分析') and c1.credit &lt;&gt; (select credit from course where cName = '移动计算')); 10.查询平均分大于等于90分的所有课程名称；12345678select cNamefrom coursewhere cNo in (select cNo from sc where score is not null group by cNo having avg(score) &gt;= 90); 11.查询选修了“离散数学”课程的所有学生姓名与成绩；123456select student.sName, sc.score from student, sc where student.sNo = sc.sNo and sc.cNo = (select cNo from course where cName = '离散数学'); 123select student.sName, sc.scorefrom (student join sc using (sNo)) join course using (cNo)where course.cName = '离散数学'; 12.查询“王兵”所选修的所有课程名称及成绩；123456select course.cName, sc.score from course natural join sc where sc.sNo in (select sNo from student where sName = '王兵'); 123456select course.cName, sc.scorefrom course join sc on course.cNo = sc.cNowhere sc.sNo in (select sNo from student where sName = '王兵'); 13.查询所有具有不及格课程的学生姓名、课程名与成绩；123select student.sName, course.cName, sc.scorefrom student, course, sc where student.sNo = sc.sNo and course.cNo = sc.cNo and sc.score &lt; 60; 14.查询选修了“文学院”开设课程的所有学生姓名；123456select s1.sName from student s1 where s1.sNo in (select distinct s2.sNo from student s2, sc, department, course where department.dName = '文学院' and course.dNo =department.dNo and course.cNo = sc.cNo and s2.sNo = sc.sNo); 15.查询“信息学院”所有学生姓名及其所选的“信息学院”开设的课程名称。123select student.sName, course.cNamefrom student, course, department, scwhere department.dName = '信息学院' and student.dNo = department.dNo and course.dNo = department.dNo and sc.sNo = student.sNo and sc.cNo = course.cNo; 1234//包含信息学院中未选信息学院课程的学生select student.sName, course.cNamefrom (student join department on (student.dNo = department.dNo)) left join (sc join course on (sc.cNo = course.cNo)) on (student.sNo = sc.sNo)where department.dName = '信息学院' and (course.dNo = department.dNo or course.dNo is null ); 四、综合1.查询所有学生及其选课信息（包括没有选课的学生）；12select student.*, sc.*from student left outer join sc on (student.sNo = sc.sNo); 2.查询“形式语言与自动机”先修课的课程名称；123456select cName from coursewhere cNo in (select cPNo from course where cName = '形式语言与自动机'); 3.查询“形式语言与自动机”间接先修课课程名称；12345678select cNamefrom coursewhere cNo in (select cPNo from course where cNo in (select cPNo from course where cName = '形式语言与自动机')); 4.查询先修课为编译原理数学的课程名称；123456select cNamefrom coursewhere cPNo in (select cNo from course where cName = '编译原理'); 5.查询间接先修课为离散数学的课程名称；123456789select cNamefrom coursewhere cPNo in (select cNo from course where cPNo in (select cNo from course where cName = '离散数学')); 6.查询所有没有先修课的课程名称；123select cName from coursewhere cPNo is null; 7.查询所有没选修“形式语言与自动机”课程的学生姓名；123456789select sNamefrom studentwhere not exists (select * from sc where sNo = student.sNo and cNo = (select cNo from course where cName = '形式语言与自动机')); 8.查询所有选修了“形式语言与自动机”但没选修其先修课的学生姓名；12345678910select student1.sNamefrom student student1, sc sc1, course course1where course1.cName = '形式语言与自动机' and student1.sNo = sc1.sNo and course1.cNo = sc1.cNoexcept select student2.sNamefrom student student2, sc sc2, course course2where course2.cNo = (select cPNo from course where cName = '形式语言与自动机') and student2.sNo = sc2.sNo and sc2.cNo = course2.cNo; 9.查询选修课程总学分大于等于28的学生姓名及其选修课程总学分；1234select student.sName, sum(credit)from (student join sc on (student.sNo = sc.sNo)) join course on (course.cNo = sc.cNo)group by student.sNohaving sum(credit) &gt;= 28; 10.查询选修了3门以上课程且成绩都大于85分的学生学号与姓名；123456select student.sNo, student.sNamefrom student join sc on (student.sNo = sc.sNo)--将会把有一门低于85的但有三门大于85的人选进来where sc.score is not null and sc.score &gt; 85group by student.sNohaving count(sc.cNo) &gt; 3; 12345select student.sNo, student.sNamefrom student join sc on (student.sNo = sc.sNo)where sc.score is not null group by student.sNohaving count(sc.cNo) &gt; 3 and min(sc.score) &gt; 85; 11.查询恰好选修了3门课并且都及格的学生姓名；123456select student.sNo, student.sNamefrom student join sc on (student.sNo = sc.sNo)--出现问题如上一题所示where sc.score is not null and sc.score &gt;= 60group by student.sNohaving count(sc.cNo) = 3; 12345select student.sNo, student.sNamefrom student join sc on (student.sNo = sc.sNo)where sc.score is not null group by student.sNohaving count(sc.cNo) = 3 and min(sc.score) &gt;= 60; 12.查询人数多于6的学院名称及其学生人数；1234select department.dName, count(student.*)from department join student on (department.dNo = student.dNo)group by department.dNohaving count(student.*) &gt; 6; 13.查询平均成绩高于王兵的学生姓名；12345678select student1.sNo, student1.sNamefrom student student1 join sc sc1 on (student1.sNo = sc1.sNo)where sc1.score is not nullgroup by student1.sNohaving (avg(sc1.score) &gt; (select avg(sc2.score) from student student2 join sc sc2 on (student2.sNo = sc2.sNo) where sc2.score is not null and student2.sName = '王兵')); 12345678910select student1.sNo, student1.sNamefrom student student1 join sc sc1 on (student1.sNo = sc1.sNo)where sc1.score is not nullgroup by student1.sNo, student1.sNamehaving (avg(sc1.score) &gt; (select max(avgScore) from (select student2.sNo, student2.sName, avg(sc2.score) from student student2 join sc sc2 on student2.sNo = sc2.sNo where sc2.score is not null group by student2.sNo, student2.sName) as s_avg(sNo, sName, avgScore) where s_avg.sName = '王兵')); 14.查询所有选修了离散数学并且选修了编译原理课程的学生姓名；12345678910select student1.sNamefrom student student1, sc sc1, course course1where course1.cName = '离散数学' and student1.sNo = sc1.sNo and course1.cNo = sc1.cNointersectselect student2.sNamefrom student student2, sc sc2, course course2where course2.cNo = (select cPNo from course where cName = '编译原理') and student2.sNo = sc2.sNo and sc2.cNo = course2.cNo; 15.查询软件学院离散数学课程平均分；123select avg(score)from sc, course, student, departmentwhere department.dName = '软件学院' and student.dNo = department.dNo and course.cName = '离散数学' and sc.cNo = course.cNo and student.sNo = sc.sNo and sc.score is not null; 16.查询年龄与“软件学院”所有学生年龄都不相同学生姓名及其年龄和学院；12345select student1.sName, student1.age, department1.dNamefrom student student1 left join department department1 on (student1.dNo = department1.dNo)where student1.age not in (select student2.age from student student2 left join department department2 on (student2.dNo = department2.dNo) where department2.dName = '软件学院' and student2.age is not null); 17.查询各学院选修同一门课人数大于4的学院、课程及选课人数；1234567select department1.dName, course1.cName, other.countsfrom department department1, course course1, (select student2.dNo, sc2.cNo, count(student2.sNo) from student student2, sc sc2 where student2.sNo = sc2.sNo group by student2.dNo, sc2.cNo having count(student2.sNo) &gt; 4) as other(dNo, cNo, counts)where department1.dNo = other.dNo and course1.cNo = other.cNo; 18.查询仅仅选修了“高等数学”一门课程的学生姓名；（学号、姓名及所在学院名称）1234567select student1.sNo, student1.sName, department1.dNamefrom (student student1 join sc sc1 on (student1.sNo = sc1.sNo)) left join department department1 on (student1.dNo = department1.dNo)where sc1.sNo not in (select sc2.sNo from sc sc2 where sc2.cNo &lt;&gt; (select course1.cNo from course course1 where course1.cName = '高等数学')); 19.查询平均学分积小于70分的学生姓名12345select student.sNamefrom (student join sc on (student.sNo = sc.sNo)) join course on (sc.cNo = course.cNo)where sc.score is not nullgroup by student.sNohaving (sum(sc.score * course.credit) / sum(course.credit)) &lt; 70; 12345select student.sNamefrom (student join sc on (student.sNo = sc.sNo)) join course on (sc.cNo = course.cNo)where sc.score is not nullgroup by student.sNohaving CAST(sum(CAST(sc.score * course.credit AS NUMERIC)) / sum(course.credit) AS DECIMAL(5,2)) &lt; 70.00; 20.查询选修了“信息学院”开设全部课程的学生姓名1234SELECT student.sName FROM student WHERE NOT EXISTS( SELECT course.cNo FROM course WHERE NOT EXISTS(SELECT sc.cNo FROM sc WHERE sc.sNo=student.sNo AND sc.cNo=course.cNo ) AND course.dNo=(SELECT department.dNo FROM department WHERE department.dName='信息学院') ); 123456789101112select sNamefrom student swhere not exists (select * from course c where c.dNo in (select dNo from department where dName = '信息学院') and not exists (select * from sc where sNo = s.sNo and cNo = c.cNo)); 21.查询选修了“杨佳伟”同学所选修的全部课程的学生姓名。123456789101112select sname from student s where not exists (select * from sc sc2 where sc2.sno= (select sno from student where sname='杨佳伟') and not exists (select * from sc sc3 where s.sno=sc3.sno and sc2.cno=sc3.cno)) and s.sname&lt;&gt;'杨佳伟'; 123456789101112131415select sNamefrom studentwhere sNo in (select distinct sNo from sc scx where not exists (select * from sc scy where scy.sNo = (select sNo from student where sName = '杨佳伟') and not exists (select * from sc scz where scz.sNo = scx.sNo and scz.cNo = scy.cNo))); DDL练习1.创建2张表，信息如下：图书（编号，书名，作者，ISBN，出版社编号，版本，出版日期）。主码为编号，ISBN唯一。出版社编号为外码，参照出版社编号。出版社（编号，名称，地址，电话）。主码为编号。要求：(1)创建表的同时创建约束；(2)删除所创建的表;(3)重新创建表，在表创建之后增加约束。123456789101112131415161718192021222324252627282930313233343536373839404142--drop table book cascade--drop table publisher cascade create table publisher( pNo varchar(20) not null, pName varchar(200), address varchar(200), TEL varchar(200), primary key(pNo));create table book ( bNo char(12) not null unique, bName varchar(200) not null, author varchar(200) not null, ISBN varchar(200) not null unique, pNo varchar(20), bVersion char(6), bDate date, primary key(bNo), foreign key(pNo) references publisher(pNo));create table publisher( pNo varchar(20) not null, pName varchar(200), address varchar(200), TEL varchar(200));create table book ( bNo char(12) not null unique, bName varchar(200) not null, author varchar(200) not null, ISBN varchar(200) not null unique, pNo varchar(20), bVersion char(6), bDate date, primary key(bNo));alter table publisher add primary key(pNo);alter table book add foreign key(pNo) references publisher(pNo); 2.分别向两张表中各插入2行数据。12345insert into publisher values('01', '机械工业出版社', '北京', '110');insert into publisher values('02', '高等教育出版社', '上海', '120');insert into book values('10086', '算法导论', 'Thomas', '9787040370683', '01', '1.0', to_date('2017-01-08','yyyy-mm-dd'));insert into book values('10000', '离散数学', 'Pony', '9787040370688', '02', '16.3', to_date('2018-01-08','yyyy-mm-dd')); 3.将其中一个出版社地址变更一下。123update publisherset address = '陕西'where pNo = '01'; 4.删除所插入数据。12345delete frombook cascade;deletefrom publisher cascade; 5.创建一个软件学院所有选修了“离散数学”课程的学生视图，并通过视图插入一行数据。123456--drop view other cascade;create view otherasselect student.sNo, student.sNamefrom student join sc on student.sNo = sc.sNo join course on sc.cNo = course.cNo join department on student.dNo = department.dNowhere department.dName = '软件学院' and course.cName = '离散数学'; 123456789101112131415drop view other cascade;create view otherasSELECT student.sNo, student.sNameFROM studentWHERE student.dNo in (SELECT department.dNo FROM department WHERE department.dName = '软件学院') and student.sNo in (SELECT sc.sNo FROM sc where sc.sNo = student.sNo and sc.cNo in (SELECT course.cNo FROM course WHERE course.cName = '离散数学')); 123insertinto othervalues('170288', '李天一'); 6.创建一个各门课程平均分视图。123456drop view AVERAGE;create view AVERAGE asselect sc.cNo, course.cName, avg(sc.score)from course join sc on course.cNo = sc.cNowhere sc.score is not nullgroup by sc.cNo, course.cName; 7.创建一张学生平均成绩表s_score(sNo,sName,avgscore),并通过子查询插入所有学生数据。123456--drop view s_score;create view s_score asselect student.sNo, student.sName, avg(sc.score)from student left join sc on student.sNo = sc.sNowhere sc.score is not nullgroup by student.sNo, student.sName 12select *from s_score; DCL尝试将多条SQL语句组成一个事务执行，体验提交和回滚操作。123456begin transaction;select *from sc;select *from student;commit;]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库关系代数练习]]></title>
    <url>%2F2019%2F01%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[现在有关系模式如下所示：1234Department(dNo,dName,officeRoom,homePage)Student(sNo,sName,sex,age,dNo)Course(cNo,cName,cPNo,credit,dNo)SC(sNo,cNo,score,recorddate) 一、基本查询 查询所有年龄小于18岁的男生姓名 \pi_{sname}(\sigma_{age3}(course)) 查询所有没有先修课的课程名称 \pi_{cname}(\sigma_{cPNo\ is\ null}(course)) 二、连接查询 查询“信息学院”所有学生姓名 \pi_{sname}((\sigma_{dname='\text{信息学院}'}(department))\Join student) 查询所有具有不及格记录的学生姓名 \pi_{sname}((\sigma_{score]]></content>
      <tags>
        <tag>数据库关系代数</tag>
      </tags>
  </entry>
</search>
